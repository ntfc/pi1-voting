/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package org.evoting.zkp;

import org.evoting.schemes.proofs.InteractiveProof;
import java.math.BigInteger;
import java.security.SecureRandom;
import org.cssi.numbers.CryptoNumbers;
import org.cssi.paillier.interfaces.PaillierPublicKey;
import org.evoting.exception.VariableNotSetException;
import org.evoting.schemes.proofs.Proof;
import org.evoting.zkp.ZKPValidM;
import org.utils.ByteUtils;

/**
 * Prove that a message lies in a given set of messages, interactive version
 *
 * @author nc
 */
public class ZKPValidMProverInt extends ZKPValidM {

  /**
   * Create the prover ZKPValidM part
   * <p/>
   * @param S Set of messages allowed
   * @param pub Paillier public key
   * @param i Index of the message in the set S
   * @param c Message encrypted
   * @param rUsedInEnc Random r such that c = E(S[i], r)
   */
  public ZKPValidMProverInt(BigInteger[] S, PaillierPublicKey pub) {
    super(S, pub);
  }

  /**
   * Step 1 of Non-Interactive ZKPValidM
   * <p>
   * <b>NOTE:</b> used by the prover P
   * <p/>
   * @param c
   * @param m Message m
   * @param rUsedInEnc
   * @return
   * @throws VariableNotSetException
   */
  public InteractiveProof generateStep1(BigInteger c, BigInteger m,
                                        BigInteger rUsedInEnc)
    throws
    VariableNotSetException {
    if (pubKey == null) {
      throw new VariableNotSetException("PaillierPublicKey not set");
    }
    for (int j = 0; j < p; j++) {
      if (S[j].compareTo(m) == 0) {
        this.i = j;
      }
    }
    if (this.i < 0) {
      // TODO: throw exception ou continuar com i = random(1..p)??
      throw new IndexOutOfBoundsException("Message m not in S!");
    }
    this.r = rUsedInEnc;
    this.C = c;
    // generate random peta in Z_n^*
    peta = CryptoNumbers.genRandomZStarN(n, new SecureRandom());

    // generate p-1 values of e
    pickRandomEValues();
    // generate p-1 values of v
    pickRandomVValues();
    // compute p values of u
    computeUValues();

    // byte array to be sent to the Verifier
    return new InteractiveProof(u);
  }

  /**
   * Receive a random challenge generated by the verifier in generateStep2
   * <p>
   * <b>NOTE:</b> used by the prover P
   * <p/>
   * @param data
   */
  public void receiveStep2(InteractiveProof p) {
    this.ch = ByteUtils.byteToArrayBigInteger(p.getProofEncoded())[0];
  }

  /**
   * P computes e_i and v_i. Then sends e and v to verifier V
   * <p>
   * <b>NOTE:</b> used by the prover P
   * <p/>
   * @return Returns an array with 2 arrays of BigIntegers (both of them as
   * a byte array): e in the first position, and v in the second
   */
  public InteractiveProof[] generateStep3() throws VariableNotSetException {
    if (pubKey == null) {
      throw new VariableNotSetException("PaillierPublicKey not set");
    }
    BigInteger eeSubtract = ch.subtract(arraySum(e));
    // e_i = ee - sum(e) mod n
    e[i] = eeSubtract.mod(n);

    // Mod(peta * (r^ei) * g^(eeSubstract/ n), n)
    v[i] = peta.multiply(this.r.modPow(e[i], n).multiply(g.modPow(eeSubtract.
      divide(n), n))).mod(n);

    // send v and e
    return new InteractiveProof[]{
        new InteractiveProof(e),
        new InteractiveProof(v)
      };
  }
}
