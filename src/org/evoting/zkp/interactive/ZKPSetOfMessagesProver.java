/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

package org.evoting.zkp.interactive;

import org.evoting.zkp.Proof;
import java.math.BigInteger;
import java.security.SecureRandom;
import org.cssi.numbers.CryptoNumbers;
import org.cssi.paillier.interfaces.PaillierPublicKey;
import org.evoting.exception.VariableNotSetException;
import org.utils.ByteUtils;

/**
 *
 * @author nc
 */
public class ZKPSetOfMessagesProver extends ZKPSetOfMessages {

  /**
   * Create the prover ZKPSetOfMessages part
   * @param S Set of messages allowed
   * @param pub Paillier public key
   * @param i Index of the message in the set S
   * @param c Message encrypted
   * @param rUsedInEnc Random r such that c = E(S[i], r)
   */
  public ZKPSetOfMessagesProver(BigInteger[] S, PaillierPublicKey pub) {
    super(S, pub);
  }

  /**
   * Step 1 of Non-Interactive ZKPSetOfMessages
   * <p>
   * <b>NOTE:</b> used by the prover P
   * @param c
   * @param i
   * @throws VariableNotSetException
   * @return The array to be sent to the verifier
   */
  public Proof generateStep1(BigInteger c, int index, BigInteger rUsedInEnc)
          throws
          VariableNotSetException {
    if (pubKey == null) {
      throw new VariableNotSetException("PaillierPublicKey not set");
    }
    this.i = index;
    this.r = rUsedInEnc;
    this.C = c;
    // generate random peta in Z_n^*
    peta = CryptoNumbers.genRandomZStarN(n, new SecureRandom());

    // generate p-1 values of e
    pickRandomEValues();
    // generate p-1 values of v
    pickRandomVValues();
    // compute p values of u
    computeUValues();
    
    // byte array to be sent to the Verifier
    return new Proof(ByteUtils.arrayBigIntegerToByte(u));
  }

  /**
   * Receive a random challenge generated by the verifier in generateStep2
   * <p>
   * <b>NOTE:</b> used by the prover P
   * @param data
   */
  public void receiveStep2(Proof p) {
    this.ch = p.getProofAsBigIntegerArray()[0];
  }

  /**
   * P computes e_i and v_i. Then sends e and v to verifier V
   * <p>
   * <b>NOTE:</b> used by the prover P
   * @return Returns an array with 2 arrays of BigIntegers (both of them as
   * a byte array): e in the first position, and v in the second
   */
  public Proof[] generateStep3() throws VariableNotSetException {
    if(pubKey == null)
      throw new VariableNotSetException("PaillierPublicKey not set");
    BigInteger eeSubtract = ch.subtract(arraySum(e));
    // e_i = ee - sum(e) mod n
    e[i] = eeSubtract.mod(n);
    
    // Mod(peta * (r^ei) * g^(eeSubstract/ n), n)
    v[i] = peta.multiply(this.r.modPow(e[i], n).multiply(g.modPow(eeSubtract.
            divide(n), n))).mod(n);
    
    // send v and e
    return new Proof[]{
                         new Proof(ByteUtils.arrayBigIntegerToByte(e)),
                         new Proof(ByteUtils.arrayBigIntegerToByte(v))
                       };
  }
}
