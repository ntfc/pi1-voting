/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package org.evoting.zkp;

import org.evoting.schemes.proofs.InteractiveProof;
import org.evoting.schemes.proofs.Proof;
import java.math.BigInteger;
import java.security.SecureRandom;
import org.cssi.numbers.CryptoNumbers;
import org.cssi.paillier.interfaces.PaillierPublicKey;
import org.evoting.exception.VariableNotSetException;
import org.utils.ByteUtils;

/**
 * Verify that a messages lies in a set of messages, interactive version
 *
 * @author nc
 */
public class ZKPValidMVerifierInt extends ZKPValidM {

  /**
   * Create the verifier ZKPValidM part
   * <p/>
   * @param S Set of messages allowed
   * @param pub Paillier public key
   * @param C Encrypted message received from prover
   */
  public ZKPValidMVerifierInt(BigInteger[] S, PaillierPublicKey pub) {
    super(S, pub);
  }

  /**
   * Receive the number generated by the prover in step 1
   * <b>NOTE:</b> used by the verifier V
   * <p/>
   * @param data
   */
  public void receiveStep1(InteractiveProof p) {
    this.u = ByteUtils.byteToArrayBigInteger(p.getProofEncoded());
  }

  /**
   * Choose a random challenge ch, with t = n.bitLength() / 2 bits
   * <p/>
   * <b>NOTE:</b> used by the verifier V
   * <p/>
   * @return The BigInteger as an array
   */
  public InteractiveProof generateStep2() throws VariableNotSetException {
    if (pubKey == null) {
      throw new VariableNotSetException("PaillierPublicKey not set");
    }
    // generate a random number, with t = k/2 bits (k = bitLength(n))
    int nBits = n.bitLength() / 2;
    this.ch = CryptoNumbers.genRandomNumber(nBits, new SecureRandom());

    return new InteractiveProof(ByteUtils.arrayBigIntegerToByte(ch));

  }

  /**
   * Receive v and e from the prover
   * <p>
   * <b>NOTE:</b> used by the verifier V
   * <p/>
   * @param data
   */
  public void receiveStep3(InteractiveProof e, InteractiveProof v) {
    this.receiveStep3(e.getProofEncoded(), v.getProofEncoded());
  }

  public void receiveStep3(byte[] e, byte[] v) {
    this.v = ByteUtils.byteToArrayBigInteger(v);
    this.e = ByteUtils.byteToArrayBigInteger(e);
  }

  /**
   * Verifier V verifies that the encrypted message C really lies in the set of
   * messages S
   * <b>NOTE:</b> used by the verifier V
   *
   * @param c Ciphertext to be verified
   * @return
   */
  public boolean verify(BigInteger c) throws VariableNotSetException {
    if (pubKey == null) {
      throw new VariableNotSetException("PaillierPublicKey not set");
    }
    this.C = c;
    boolean ret;
    // sum(ej) mod n
    BigInteger ejSum = arraySum(e).mod(n);
    // check that e = sum(ej) mod n
    ret = ch.compareTo(ejSum) == 0;

    for (int j = 0; j < e.length && ret; j++) {
      BigInteger vjN = v[j].modPow(n, nSquare);
      // vjNToCheck = u_j * (C/g^m_j)^e_j mod n^2
      BigInteger vjNToCheck = u[j].multiply(C.multiply(g.pow(S[j].intValue()).
        modInverse(nSquare)).modPow(e[j], nSquare)).mod(nSquare);
      // verify
      ret = vjN.compareTo(vjNToCheck) == 0;

    }
    return ret;
  }
}
